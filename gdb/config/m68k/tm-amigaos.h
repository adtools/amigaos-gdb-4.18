/* Macro definitions for GDB on a Commodore Amiga running AmigaOS.
   Copyright (C) 1994, Free Software Foundation, Inc.
   Written by Fred Fish at Cygnus Support (fnf@cygnus.com)

This file is part of GDB.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Define BPT_VECTOR if it is different than the default.
   This is the vector number used by traps to indicate a breakpoint. */

#define BPT_VECTOR 0x1

/* Use the alternate method of determining valid frame chains. */

#define FRAME_CHAIN_VALID_ALTERNATE

#ifdef __amigaos__
#define FRAME_FIND_SAVED_REGS(fi,fsr) amigaos_find_saved_regs ((fi), &(fsr))
#endif

/* Advance PC across any function entry prologue instructions
   to reach some "real" code.  */

#ifdef __amigaos__
#define SKIP_PROLOGUE(ip)   {(ip) = amigaos_skip_prologue(ip);}
extern CORE_ADDR amigaos_skip_prologue PARAMS ((CORE_ADDR ip));

#define SKIP_TRAMPOLINE_CODE(pc) (amigaos_skip_trampoline_code(pc))
extern CORE_ADDR amigaos_skip_trampoline_code(CORE_ADDR pc);
#endif

/* When creating a dummy frame, GDB should leave this many bytes between
   the SP and the start of the frame. The space in between contains the
   exception frame pushed by the ixemul trap handler. It is also used as
   stack space by the stopped_process_handler from ixemul, so don't make
   this value too small. */
#define STACK_SPACE_FOR_DUMMY_FRAME 2048

#include "m68k/tm-m68k.h"

#define PC_IN_CALL_DUMMY(pc, sp, frame_address) amigaos_pc_in_call_dummy(pc, sp, frame_address)
extern int amigaos_pc_in_call_dummy(CORE_ADDR pc, CORE_ADDR sp, CORE_ADDR frame_address);

#if __amigaos__
#undef PUSH_DUMMY_FRAME
#define PUSH_DUMMY_FRAME	{ amigaos_push_dummy_frame (); }
extern void amigaos_push_dummy_frame PARAMS ((void));
#endif

#if __amigaos__
#undef POP_FRAME
#define POP_FRAME		{ amigaos_pop_frame (); }
extern void amigaos_pop_frame PARAMS ((void));
#endif

/* replace moveml d0-a5,sp@- by moveml d0-a4/a6,sp@- */
#undef CALL_DUMMY
#define CALL_DUMMY {0xf227e0ff, 0x48e7fffa, 0x426742e7, 0x4eb93232, 0x3232dffc, 0x69696969, (0x4e404e71 | (BPT_VECTOR << 16))}

/* We define our own FIX_CALL_DUMMY. Just before we hit the breakpoint, the
   CALL_DUMMY code increases the stack pointer in order to reclaim the
   arguments pushed on the stack. However, we should also reclaim the extra
   STACK_SPACE_FOR_DUMMY_FRAME we used to skip the exception frame. GDB resets
   the stack pointer to its original value from before the call dummy. The
   exception frame generated by the breakpoint at the end of CALL_DUMMY is
   still 192 bytes lower than usual, because GDB resets the stack pointer
   only after the breakpoint, so from the viewpoint of the program the stack
   still contained the dummy frame.  But this extra space is reclaimed as soon
   as GDB resumes the debugged program.
*/

#undef FIX_CALL_DUMMY
#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, args, type, gcc_p)     \
{ bfd_putb32 (fun,     (unsigned char *) dummyname + CALL_DUMMY_START_OFFSET + 2);  \
  bfd_putb32 (nargs*4+STACK_SPACE_FOR_DUMMY_FRAME, (unsigned char *) dummyname + CALL_DUMMY_START_OFFSET + 8); }

/* Offsets (in target ints) into jmp_buf.  Not defined in any system header
   file, so we have to step through setjmp/longjmp with a debugger and figure
   them out.  As a double check, note that <setjmp> defines _JBLEN as 17,
   which matches the number of elements we see saved by setjmp(). */

#define JB_ELEMENT_SIZE sizeof(int)	/* jmp_buf[_JBLEN] is array of ints */

#define JB_ONSTACK	0
#define JB_OLDSIGNAL	1
#define JB_SP		2
#define JB_FP		3
#define JB_NESTCNT	4
#define JB_PC		5
#define JB_SR		6
#define JB_D2		7
#define JB_D3		8
#define JB_D4		9
#define JB_D5		10
#define JB_D6		11
#define JB_D7		12
#define JB_A2		13
#define JB_A3		14
#define JB_A4		15
#define JB_A6		16

/* Figure out where the longjmp will land.  Slurp the args out of the stack.
   We expect the first arg to be a pointer to the jmp_buf structure from which
   we extract the pc (JB_PC) that we will land at.  The pc is copied into ADDR.
   This routine returns true on success */

#define GET_LONGJMP_TARGET(ADDR) get_longjmp_target(ADDR)

/* Initializer for an array of names of registers.
   Entries beyond the first NUM_REGS are ignored.  */

#undef REGISTER_NAMES
#define REGISTER_NAMES  \
 {"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", \
  "a0", "a1", "a2", "a3", "a4", "fp", "a6", "sp", \
  "ps", "pc",  \
  "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7", \
  "fpcontrol", "fpstatus", "fpiaddr", "fpcode", "fpflags" }

#undef FP_REGNUM
#define FP_REGNUM 13

#ifdef __amigaos__
#define IN_SIGTRAMP(pc, name) amigaos_in_sigtramp(pc)
int amigaos_in_sigtramp(CORE_ADDR pc);
#endif

#undef FRAME_SAVED_PC
#define FRAME_SAVED_PC(FRAME) \
    (read_memory_integer ((FRAME)->frame + 4, 4))

#ifdef __amigaos__
extern int amigaos_enforcer;

#define	ADDITIONAL_OPTIONS \
	{"enforcer", no_argument, &amigaos_enforcer, 1},

#define	ADDITIONAL_OPTION_HELP \
	"\
  --enforcer         Enter the debugger when an Enforcer hit occurs.\n\
"

extern void amigaos_install_enforcer_handler(void);
#define BEFORE_MAIN_LOOP_HOOK amigaos_install_enforcer_handler()
#endif
